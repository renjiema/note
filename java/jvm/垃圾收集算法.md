# 垃圾收集算法

本文不过都讨论算法实现，中间介绍分到收集理论和几种算法思想及其发展过程。从如何判断对象是否被引用的角度出发，垃圾收集算法可分为“引用计数式垃圾收集”(Reference Counting GC)和“追踪式垃圾收集”(Tracing GC)。本文只介绍Tracing GC算法。

## 分代收集理论

当前商业虚拟机的垃圾收集器，大多都遵循分代收集（Generational Collection）理论进行设计，分代收集实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假设之上：

* Weak Generational Hypothesis：绝大多数对象都是朝生夕灭。
* Strong Generational Hypothesis：熬过越多次垃圾收集过程的对象越难消亡。

多款常用垃圾收集器基于以上假设实现了一致的设计原则：收集器应该将Java堆划分为不同的区域，将对象根据年龄分配到不同的区域。将朝生夕灭的对象集中放在一起，每次回收时只关注如何保留少了存活对象而不是标记大量要被回收的对象，就能以较低嗲家回收到大量空间。将难以消亡的对象几种放在一起，可使用较低频率来回收该区域就实现了垃圾收集的时间开销和内存空间的有效利用。

Java堆划分出不同区域后，垃圾收集器可每次只回收某个或某些部分的区域，因此有了“Minor GC”、“Major GC”、“Full GC”这样的回收类型的划分。也可针对不同区域存储的对象特征使用更有效的垃圾收集算法，因此发展出“标记-赋值算法”、“标记-清除算法”、“标记-整理算法”等针对性的垃圾收集算法。

基于分代收集理论，设计者一般至少会把Java堆划分为新生代（Young Generation）和老年代（Old Generation）两个区域。

分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：对象不是孤立的，对象之间会存在跨代引用。假如要进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是有可能被老年代所引用的，为了找出该区域中的存活对象，必须在固定的GC Roots之外，再遍历整个老年代中所有对象来确保可达性分析结果的正确性。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：

* Intergenerational Reference Hypothesis：跨代引用相对于同代引用来说仅占极少数。

这其实是可根据前两条假说逻辑推理得出的隐含推论：存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。

因此不必为了少量的跨代引用扫描整个老年代，也不必浪费空间记录每个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（称为“记忆集”，Remembered Set），该结构将老年代划分为多个小块，标识出老年代中存在跨代引用的区域。当发生Minor GC时，只扫描包含了跨代引用的小块内存即可。该方法需要在对象改变引用关系时维护记录数据的正确性，增加一些运行时开销，但是相对与扫描整个老年代而言任然很划算。

不同分代的GC类型如下：

* 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：
  ■新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
  ■老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。
  ■混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
* 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。

## 标记-清除算法

Mark-Sweep算法分为“标记”和“清除”两个阶段：首先扁家说所有需要回收的对象，完成标记后，统一回收所有标记的对象，也可以反过来标记存活的对象。

其他的收集算法大多都是以标记-清除算法为基础，对齐缺点改进而得。它的主要缺点有两个：

* 执行效率不稳定，如果java堆中包含大量对象且大部分需要被回收，就必须进行大量标记和清除操作，执行效率会降低。
* 内存空间的碎片化问题，标记和清除之后会产生大量的不连续内存碎片，大量的内存碎片导致分配较大对象时无法找到足够的连续内存而必须提前触发新的垃圾收集动作来获取足够内存。

标记-清除算法的执行过程如下图所示：

![](https://raw.githubusercontent.com/renjiema/images/main/blogs/20210512222855.png)

## 标记-复制算法

标记-复制算法通常简称为复制算法，复制算法解决了标记-清除算法大量可回收对象时执行效率低的问题。其中“半区复制”（Semispace Copying）算法将可用内存划分为两个大小相等的区域，每次使用其中一个快，当该块内存用尽就将存活的对象复制到另外一个块上，再将使用的内存空间清空。对于多数可回收的清空，该算法只需要复制少量的存活对象，每次分配内存时只需要移动堆顶指针，按序分配即可。不过这种算法的缺点时将可用内存缩小为原来的一半，浪费大量的存储空间。半区复制执行过程如下图：

![image-20210513093717505](https://raw.githubusercontent.com/renjiema/images/main/blogs/20210513093724.png)

现在的商用Java虚拟机大多都采用复制算法回收新生代，为了解决内存空间过多浪费的问题，在1989年，Andrew Appel针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制分代策略，现在称为“Appel式回收”。

Appel式回收将新生代分为一个较大的Eden空间和两个较小的Survivor空间，分配内存时只是用Eden和一种一块Survivor，垃圾收集时将Eden和Survivor中存活的对象复制到另一块Survivor中，然后清空Eden和使用的Survivor。HotSpot默认Eden和Survivor的大小为8：1，所以每次新生代的可用内存空间占整个新生代的90%，大幅节约了空间的浪费。但是不能百分百保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个补救设计，当Survivor空间不足以容纳一次Minor GC后存活的对象时，需要依赖其他内存区域（一般是老年代）进行分配担保（Handle Promotion）。

> 注：本文为《深入理解Java虚拟机：JVM高级特性与最佳实战》读书笔记