# 垃圾收集算法

本文不过都讨论算法实现，中间介绍分到收集理论和几种算法思想及其发展过程。从如何判断对象是否被引用的角度出发，垃圾收集算法可分为“引用计数式垃圾收集”(Reference Counting GC)和“追踪式垃圾收集”(Tracing GC)。本文只介绍Tracing GC算法。

## 分代收集理论

当前商业虚拟机的垃圾收集器，大多都遵循分代收集（Generational Collection）理论进行设计，分代收集实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假设之上：

* Weak Generational Hypothesis：绝大多数对象都是朝生夕灭。
* Strong Generational Hypothesis：熬过越多次垃圾收集过程的对象越难消亡。

多款常用垃圾收集器基于以上假设实现了一致的设计原则：收集器应该将Java堆划分为不同的区域，将对象根据年龄分配到不同的区域。将朝生夕灭的对象集中放在一起，每次回收时只关注如何保留少了存活对象而不是标记大量要被回收的对象，就能以较低嗲家回收到大量空间。将难以消亡的对象几种放在一起，可使用较低频率来回收该区域就实现了垃圾收集的时间开销和内存空间的有效利用。

Java堆划分出不同区域后，垃圾收集器可每次只回收某个或某些部分的区域，因此有了“Minor GC”、“Major GC”、“Full GC”这样的回收类型的划分。也可针对不同区域存储的对象特征使用更有效的垃圾收集算法，因此发展出“标记-赋值算法”、“标记-清除算法”、“标记-整理算法”等针对性的垃圾收集算法。

基于分代收集理论，设计者一般至少会把Java堆划分为新生代（Young Generation）和老年代（Old Generation）两个区域。

分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：对象不是孤立的，对象之间会存在跨代引用。假如要进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是有可能被老年代所引用的，为了找出该区域中的存活对象，必须在固定的GC Roots之外，再遍历整个老年代中所有对象来确保可达性分析结果的正确性。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：

* Intergenerational Reference Hypothesis：跨代引用相对于同代引用来说仅占极少数。

这其实是可根据前两条假说逻辑推理得出的隐含推论：存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。

因此不必为了少量的跨代引用扫描整个老年代，也不必浪费空间记录每个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（称为“记忆集”，Remembered Set），该结构将老年代划分为多个小块，标识出老年代中存在跨代引用的区域。当发生Minor GC时，只扫描包含了跨代引用的小块内存即可。该方法需要在对象改变引用关系时维护记录数据的正确性，增加一些运行时开销，但是相对与扫描整个老年代而言任然很划算。

不同分代的GC类型如下：

* 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：
  ■新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
  ■老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。
  ■混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
* 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。

## 标记-清除算法

Mark-Sweep算法分为“标记”和“清除”两个阶段：首先扁家说所有需要回收的对象，完成标记后，统一回收所有标记的对象，也可以反过来标记存活的对象。

其他的收集算法大多都是以标记-清除算法为基础，对齐缺点改进而得。它的主要缺点有两个：

* 执行效率不稳定，如果java堆中包含大量对象且大部分需要被回收，就必须进行大量标记和清除操作，执行效率会降低。
* 内存空间的碎片化问题，标记和清除之后会产生大量的不连续内存碎片，大量的内存碎片导致分配较大对象时无法找到足够的连续内存而必须提前触发新的垃圾收集动作来获取足够内存。

标记-清除算法的执行过程如下图所示：

![](https://raw.githubusercontent.com/renjiema/images/main/blogs/20210512222855.png)

> 注：本文为《深入理解Java虚拟机：JVM高级特性与最佳实战》读书笔记