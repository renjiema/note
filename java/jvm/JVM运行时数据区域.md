# JVM运行时数据区域

![image-20210509183104995](https://raw.githubusercontent.com/renjiema/images/main/blogs/20210513103647.png)

运行时数据图

## 程序计数器

由于Java虚拟机的多线程时通过线程轮流切换、分配处理器执行时间的方式来实现的，在任意时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，这类内存区域为线程私有的内存。程序计数器是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。

## Java虚拟机栈

与程序计数器一样，Java Virtual Machine Stack也是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储`局部变量表`、`操作数栈`、`动态连接`、`方法出口`等信息。每个方法调用到执行完毕就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

局部变量表存放了编译器可知的各种Java虚拟机基本数据类型、对象引用（reference类型）和returnAddress类型（指向了一条字节码指令的地址）。这些数据类型在局部变量表中的存储空间以局部变量槽（slot）来表示，其中64位的long和都变了类型的数据会占用两个变量槽，其余的数据类型占用一个。方法运行期间的槽数量不变。

在《Java虚拟机规范》中，对Java虚拟机栈规定了两类异常状况：如果线程请求的栈深度大于虚拟机所运行的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。

## 本地方法栈

本地方法栈和虚拟机栈很类似，区别就是本地方法栈是为虚拟机使用到的本地（Native）方法服务。

## Java堆

Java Heap时JVM所管理的内存中最大的一块。java堆时一块被多有线程共享的内存区域，在虚拟机启动时创建。此内存的唯一目的就是存放对象实例，几乎所有的对象实例都在堆上分配内存。**几乎**是值从现实角度来看，随着Java语言的发展，能看到些许迹象表明日后可能出现值类型的支持，就目前而言，由于即使编译技术的进步，尤其是`逃逸分析`技术的日渐强大，栈上分配、标量替换优化手段已经导致一些微妙的变化悄然发生。

Java堆是垃圾收集器管理的内存区域，从回收内存的角度，由于先到垃圾手机器大部分都是基于分带收集理论设计的，所以Java堆中经常出现`新生代`、`老年代`、`永久代`、`Eden空间`、`From Survivor空间`、`To Survivor空间`等名词。

如果从分配内存的角度，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。

根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。

Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。

## 方法区

方法区和Java堆一样，是各个线程共享的内存区域，用于春初已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓冲等数据。虽然《Java虚拟机规范》中把方法去描述为堆的一个逻辑部分，但它却有一个别名叫“NonHeap”，目的是与Java堆区分开来。

说到方法区，不得不提一下“永久代”这个概念，尤其是在JDK 8以前，许多Java程序员都习惯在HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。但是对于其他虚拟机实现，譬如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。但现在回头来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法（例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。当Oracle收购BEA获得了JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta-space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。

## 运行时常量池

Runtime Constant Pool是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等表述信息，还有常量池表（Constant Pool Table）用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 

Java虚拟机对于Class文件每一部分（自然也包括常量池）的格式都有严格规定，如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池，《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。

运行时常量池相对于Class文件常量池的一个重要特征是具备动态性，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。

## 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但直接内存使用不当也可能导致OutOfMemoryError异常。

在JDK1.4中新加入的NIO类，引入了基于Channelled与Buffer的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。避免了在Java堆和Native堆中来回复制数据。