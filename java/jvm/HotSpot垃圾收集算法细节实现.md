# HotSpot垃圾收集算法细节实现



## 根节点枚举

固定的GC Roots节点主要在全局性的引用与执行上下文（栈帧中的本地变量表）中，尽管目标明确，但要在数百上千兆的内存空间中高效查找并非一件容易的事情。

目前所有收集器在根节点枚举这一步都必须Stop The World。现在可达性分析算法好使最长的查找引用链的过程已经可以做到与用户线程一起并发([并发的可达性分析](#并发的可达性分析)），但根节点枚举还是必须在一个能保证一致性的快照中才得以进行。

目前主流的Java虚拟机都是使用准确式垃圾收集，当用户线程暂停后，虚拟机有办法直接得到哪些地方存放着对象引用，因此不需要检查所有执行上下文和全局的引用位置。HotSpot使用一组称为OopMap的数据结构来达到目的，类加载动作完成时，HotSpot就把对象内偏移量上对应的类型数据计算出来，在即时编译过程中，会在特点的位置记录下栈里和寄存器里哪些位置是引用。因此收集器在扫描时可直接获取到信息，不需要全部遍历检查。

## 安全点

在OopMap的协助下，HotSpot可以快速准确的完成GC Roots枚举，但是导致OopMap内容变化的指令非常多，如果每条指令都生成对应的OopMap将需要大量的额外存储空间。

实际上HotSpot只在“特定的位置”记录这些信息，这些位置称为安全点（Safepoint）。有了安全点设置，用户线程并非在代码指令流的任意位置都能暂停，必须执行到达安全点后才能够暂停。因此，安全点的选定既不能太少以至于让收集器等待时间过长，也不能太多以至于过分增大运行时的内存负荷。安全点选取基本上遵循“是否具有让程序长时间执行的特征”标准，“长时间执行”的最明显特征就是**指令序列的复用**，例如**方法调用**、**循环跳转**、**异常跳转**等。

选定了安全点，如何让垃圾收集发生时所有线程（不包括JNI调用的线程）都跑到最近的安全点暂停也是需要考虑的问题。有如下两种方案可供选择：

* 抢先式中断（Preemptive Suspension）：不需要线程的执行代码主动配合，在垃圾收集时，系统先把所有用户线程全部中断，将不在安全点的线程恢复运行，一会儿再重新中断，直到跑到安全点上。现在基本没有虚拟机采用抢先式终端来暂停线程响应GC事件。
* 主动式终端（Voluntary Suspension）：当垃圾收集时，不直接堆线程操作，仅仅设置一个标志位，各个线程执行过程时会不停轮询这个标志位，一旦发现中断标志就在自己最近的安全点上主动中断挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。

因为轮询操作会十分频繁，所以必须足够高效。HotSopt使用**内存保护陷阱**方式，将轮询操作精简至一条汇编指令。当需要暂停用户线程时，虚拟机把**0x160100**的内存页设置为不可读，HotSpot使用test指令实现轮询，当线程执行到test指令时会产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待。轮询指令如下：

```
0x01b6d627: call   0x01b2b210          ; OopMap{[60]=Oop off=460}
                                       ; *invokeinterface size
                                       ; - Client1::main@113 (line 23)
                                       ;   {virtual_call}
    0x01b6d62c: nop                    ; OopMap{[60]=Oop off=461}
                                       ; *if_icmplt
                                       ; - Client1::main@118 (line 23)
    0x01b6d62d: test   %eax,0x160100   ;   {poll}
    0x01b6d633: mov    0x50(%esp),%esi
    0x01b6d637: cmp    %eax,%esi
```

## 安全区域

安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是，程序“不执行”的时候（用户线程处于Sleep状态或者Blocked状态）线程无法响应虚拟机的中断请求，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。因此引入了安全区域（Safe Region）来解决。

安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。

当用户线程执行到安全区时，会标识自己进入到安全区域，当虚拟机发起垃圾收集时不用管再安全区域的线程，当线程要离开安全区域时，必须检查虚拟机是否完成了根节点枚举或其他需要暂停用户线程的阶段，如果完成了线程继续执行，否则就挂起线程等待。

## 记忆集和卡表

为了解决分代收集理论中对象跨代引用的问题，垃圾收集器再新生代中共建立记忆集（Remembered Set），用以避免扫描整个老年代。实际上所有设计部分区域收集（Partial GC）的垃圾收集器（G1、ZGC和Shenandoah收集器）都会面临相同的问题，因此下文进一步了解记忆集的原理和实现方式。

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构，在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就行，并不需要了解跨代指针的全部细节。因此在实现记忆集时可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本，以下为一些可选择的记录精度：

* 字长精度：每个记录精确到一个机器字长，该字包含跨代指针。
* 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。
* 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。

卡表（Card Table）就是“卡精度”的实现方式，这也是目前最常用的一种记忆集实现。

卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这样做的。以下这行代码是HotSpot默认的卡表标记逻辑：

```
CARD_TABLE [this address >> 9] = 0;
```

字节数组（CARD_TABLE）的每一个元素都对应着内存区域中一块特定大小的内存块，这个内存块被称作**卡页**（Card Page）。一般来说，卡页大小都是以2的N次幂的字节数，上述HotSpot实现中使用的卡页是512字节（地址右移9位，相当于用地址除以512）。如果卡表标识内存区域的起始地址是0x0000，数组CARD_TABLE的第0、1、2号元素，分别对应了地址范围为0x0000～0x01FF、0x0200～0x03FF、0x0400～0x05FF的卡页内存块。

一个卡页中通常包含多个对象，只要有一个对象的字段存在跨代引用指针，就将对应卡表的数组值标识为1，称为元素变脏（Dirty），没有标识为0。

## 写屏障

上文中的卡表可以缩减GC Roots扫描范围，接下来了解卡表元素如何维护（何时变脏，谁来变脏）。

卡表元素何时变脏的答案是很明确的——有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。假如是解释执行的字节码，虚拟机负责每条字节码指令的执行，有充分的介入空间；但在编译执行的场景中，经过即时编译后的代码已经是纯粹的机器指令流，必须找到一个在机器码层面的手段，把维护卡表的动作放到每一个赋值操作之中。

HotSpot通过写屏障（Write Barrier）技术维护卡表状态。写屏障可看作虚拟机层面对“引用类型字段赋值”操作的AOP切面，在引用对象赋值时产生一个环（Around，包含Pre-Write Barrier和Post-Write Barrier）通知，可执行额外的动作。HotSpot虚拟机在G1收集器出现前，其他收集器都只用到了Post-Write Barrier。

使用写屏障后，虚拟机会为所有赋值操作生成响应的指令，如果在写屏障中增加了更新卡表的操作，无论更新的是否是老年代对新生代对象的引用，每次只要对引用更新就会产生额外的开销。

除此之外，卡表在高并发下还面临着**伪共享**（False Sharing）问题。伪共享是处理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低。

假设处理器的缓存行大小为64字节，由于一个卡表元素占1个字节，64个卡表元素将共享同一个缓存行。这64个卡表元素对应的卡页总的内存为32KB（64×512字节），也就是说如果不同线程更新的对象正好处于这32KB的内存区域内，就会导致更新卡表时正好写入同一个缓存行而影响性能。为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏，即将卡表更新的逻辑变为以下代码所示：

```
if (CARD_TABLE [this address >> 9] != 1)
    CARD_TABLE [this address >> 9] = 1;
```

在JDK7之后，HotSpot虚拟机增加了一个新的参数`-XX：+UseCondCardMark`，用来设置是否开启卡表更新的条件判断。

## 并发的可达性分析

当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析，这意味着必须全程冻结用户线程的运行。在[根节点枚举](#根节点枚举)步骤中，由于GC Roots相比起整个Java堆中全部的对象毕竟还算是极少数，且在各种优化技巧（如OopMap）的加持下，它带来的停顿已经是非常短暂且相对固定（不随堆容量而增长）的了。可从GC Roots再继续往下遍历对象图，这一步骤的停顿时间就必定会与Java堆容量直接成正比例关系了：堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长.

要解决用户线程停顿过程的问题，就要先了解为什么必须在一个能保证一致性的快照上才能进行对象图的遍历。因此引入**三色标记**（Tri-color Marking）类辅助推导：

* 白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
* 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
* 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

收集器在对象图上标记颜色，同时用户线程在修改引用关系——即修改对象图的结构，这样可能出现两种后果。一种是把原本消亡的对象错误标记为存活，这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好。另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此发生错误，下面图演示了这样的致命错误具体是如何产生的。

![image-20210514141830115](https://raw.githubusercontent.com/renjiema/images/main/blogs/20210514141830.png)

Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：

* 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
* 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）。

* 增量更新：当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。应用：CMS。
* 原始快照：灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。应用：G1、Shenandoah。

> 注：本文为《深入理解Java虚拟机：JVM高级特性与最佳实战》读书笔记

