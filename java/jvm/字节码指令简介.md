# 字节码指令简介

Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成。

* **劣势**：由于限制了Java虚拟机操作码的长度为一个字节（即0～255），并且Class文件格式放弃了编译后代码的操作数长度对齐，因此虚拟机在处理那些超过一个字节的数据时，必须在运行时从字节中重建出具体数据的结构，譬如要将一个16位长度的无符号整数使用两个无符号字节存储起来（假设将它们命名为byte1和byte2），那它们的值应该是这样的：`(byte1 << 8) | byte2`，这种操作在某种程度上会导致解释执行字节码时将损失一些性能。
* **优势**：放弃了操作数长度对齐，就意味着可以省略掉大量的填充和间隔符号；用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码。（除了`tableswitch`和`lookupswitch`两条指令例外，由于它们的操作数比较特殊，是以4字节为界划分开的，所以这两条指令也需要预留出相应的空位填充来实现对齐。）

对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference。也有一些指令的助记符中没有明确指明操作类型的字母，例如arraylength指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。还有另外一些指令，例如无条件跳转指令goto则是与数据类型无关的指令。

因为Java虚拟机的操作码长度只有一字节，指令集将会被故意设计成非完全独立的。（《Java虚拟机规范》中把这种特性称为“Not Orthogonal”，即并非每种数据类型和每一种操作都有对应的指令。）有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。

下表举了Java虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型列所代表的特殊字符替换opcode列的指令模板中的T，就可以得到一个具体的字节码指令。

![image-20210615160524666](https://raw.githubusercontent.com/renjiema/images/main/blogs/20210615160933.png)

从上表中看来，大部分指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。

下面将字节码操作按用途大致分为9类，概略介绍这些指令的用法。

## 1.加载和存储指令

加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括：

* 将一个局部变量加载到操作栈：iload、iload\_\<n>、lload、lload\_\<n>、fload、fload\_\<n>、dload、dload\_\<n>、aload、aload\_\<n>
* 将一个数值从操作数栈存储到局部变量表：istore、istore_\<n>、lstore、lstore\_\<n>、fstore、fstore\_\<n>、dstore、dstore\_\<n>、astore、astore\_\<n>
* 将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst\_\<i>、lconst\_\<l>、fconst\_\<f>、dconst\_\<d>
* 扩充局部变量表的访问索引的指令：wide

上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload\_\<n>），这些指令助记符实际上代表了一组指令（例如iload_\<n>，它代表了iload_0、iload_1、iload_2和iload_3这几条指令）。这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，省略掉了显式的操作数，不需要进行取操作数的动作。除了这点不同以外，它们的语义与原生的通用指令是完全一致的。

