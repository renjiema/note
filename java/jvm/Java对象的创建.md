# HotSpot虚拟机对象探索

## 对象的创建

本文仅讨论普通Java对象的new过程。当Java虚拟机遇到一条字节码new指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是非已经被`加载`、`解析`和`初始化`过。如果没有，那必须执行相应的类加载过程。

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。所需的内存大小在类加载后便可确定。Java堆分配内存一般有两种方式：指针碰撞（Bump The Pointer）、空闲列表（Free List）。

* 指针碰撞：假设Java堆内存绝对规整，被使用内存和空闲内存分隔两边，中间存在一指针最为分界点的指示器，分配内存就是把指针向空虚内存方向移动与对象大小相等的距离。
* 空闲列表：虚拟机维护一个空闲内存列表，分配内存时从列表中找到一块足够大的空间分配给对象实例，并更新列表内容。

分配方式由Java堆是否规整决定，Java堆的是否规整由垃圾收集器是否带压缩整理的能力决定。因此，当使用`Serial`、`ParNew`等带压缩整理的收集器时，采用指针碰撞即简单又高效，而使用CMS这类基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。不过在CMS的实现里面，为了能在多数情况下分配得更快，设计了一个叫作Linear Allocation Buffer的分配缓冲区，通过空闲列表拿到一大块分配缓冲区之后，在它里面仍然可以使用指针碰撞方式来分配

除了内存空间划分外，还需要考虑并发问题，对象的创建在虚拟机中非常频繁，即使修改一个指针所指向的位置，在并发下也非线程安全。Java虚拟机有两种可选的解决方法：

* 同步操作：使用CAS加失败重试机制保证更新操作的原子性；
* TLAB：本地线程分配缓冲（Thread Local Allocation Buffer），每个线程在Java堆中预先分配一小块内存，为对象分配内存时先使用本地缓冲区内存，本地缓冲区用完后再使用同步操作。可通过`-XX:+/-UseTLAB`参数配置是否开启TLAB。

内存分配完成后，虚拟机将除对象头以外的内存空间初始化为零值，如果使用了TLAB也可在TLAB分配内存时完成。

接下来虚拟机还要设置必要的对象头信息，例如Class信息，如何找到类的元数据信息、对象的哈希码（实际调用hashCode()方法时才计算）、对象的GC分代年龄信息、是否启用偏向锁等。

完成以上操作，堆虚拟机来说一个对象已经产生了，但从Java程序来看，对象的创建才刚开始——构造函数（Class文件中的<init>()方法还没执行），执行init()方法安装预定的意图构造好对象需要的其他资源和状态信息，一个可用的对象才算完全被创建出来。

## 对象的内存布局

在HotSpot虚拟机中，对象在堆中的存储布局可分为三个部分：Header、Instance Data、Padding。

### Header

HotSpot虚拟机对象的对象头包括两类信息。第一类信息官方称它为`Mark Word`，用于存储对象自身的运行时数据：HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。

`Mark Word`被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据。在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态下，Mark Word的32个byte存储空间中的25个byte用于存储对象哈希码，4个byte用于存储对象分代年龄，2个byte用于存储锁标志位，1个byte固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示

| 存储内容                             | 标志位 | 状态       |
| ------------------------------------ | ------ | ---------- |
| 对象哈希码、对象分代年龄             | 01     | 未锁定     |
| 指向锁记录的指针                     | 00     | 轻量级锁定 |
| 指向重量级锁的指针                   | 10     | 重量级锁定 |
| 空，不需要记录信息                   | 11     | GC标记     |
| 偏向线程ID、偏向时间戳、对象分代年龄 | 01     | 可偏向     |

对象头的另一部分是类型指针，指向它的类型元数据。HotSpot虚拟机通过该指针确定对象是哪个类的实例。并不是所有虚拟机实现都在对象数据上保存类型指针。此外，如果是数组对象，对象头中还必须有一块记录数组长度的数据。

### Instance Data

实例数据存储对象真正的有效信息：我们在程序代码里定义的各种类型字段（包括从父类继承的）。该部分的存储顺序收到虚拟机分配策略参数（`-XX: FieldsAllocationStyle`)和Java源码中字段定义顺序影响。HotSpot虚拟机默认的分配顺序中相同宽度的字段总是被分配到一起存放，具体顺序：longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs），并且在此前提下父类的变量会在子类之前。如果HotSpot虚拟机的+XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。

### Padding

因为HotSpot虚拟机的自动内存管理系统要求对象其实地址必须是8字节的整数倍，因此如果对象实例数据没有对齐，就需要通过padding来对齐。

## 对象的访问定位

对象创建后，Java程序会通过栈上的reference数据来操作堆上的具体对象。reference主要有两种访问堆中对象的具体位置的方式：使用句柄、直接指针

* 句柄访问：Java堆中将可能会划分出一块内存作为句柄池，reference中存储**对象的句柄地址**，句柄中包含对象实例数据和类型数据的地址信息。使用句柄来访问的最大好处在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。
* 直接指针：Java堆中的对象的内存布局必须考虑如何放置访问类型数据的相关信息，reference中存储**对象地址**，如果只访问对象本身就不需要多一次间接访问开销，因此速度更快。HotSpot主要使用第二种方式访问对象。

> 注：本文为《深入理解Java虚拟机：JVM高级特性与最佳实战》读书笔记