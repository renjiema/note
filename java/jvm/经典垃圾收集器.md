# 经典垃圾收集器

本文讨论的是在JDK 7 Update 4之后（在这个版本中正式提供了商用的G1收集器，此前G1仍处于实验状态）、JDK 11正式发布之前，OracleJDK中的HotSpot虚拟机所包含的全部可用的垃圾收集器。

![image-20210514143145905](https://raw.githubusercontent.com/renjiema/images/main/blogs/20210514143145.png)

上图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用[^1]，接下来将逐一介绍这些收集器的目标、特性、原理和使用场景，并重点分析CMS和G1这两款相对复杂而又广泛使用的收集器，深入了解它们的部分运作细节。

## Serial收集器

Serial收集器是最基础、历史最悠久的收集器。Serial进行垃圾收集是，必须暂停所有用户线程并启动一个处理器或线程去完成垃圾收集工作。下图演示了Serial/Serial Old收集器的运行过程。

![image-20210514151133295](https://raw.githubusercontent.com/renjiema/images/main/blogs/20210514151133.png)

迄今为止，Serial收集器依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，因为简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户桌面的应用场景以及近年来流行的部分微服务应用中，分配给虚拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代（仅仅是指新生代使用的内存，桌面应用甚少超过这个容量），垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一百多毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说是完全可以接受的。


[^1]:这个关系不是一成不变的，由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃，并在JDK 9中完全取消了这些组合的支持。

> 注：本文为《深入理解Java虚拟机：JVM高级特性与最佳实战》读书笔记

